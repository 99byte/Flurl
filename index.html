<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Flurl by tmenier</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      <div id="header">
        <nav>
          <li class="fork"><a href="https://github.com/tmenier/Flurl">View On GitHub</a></li>
          <li class="downloads"><a href="https://github.com/tmenier/Flurl/zipball/master">ZIP</a></li>
          <li class="downloads"><a href="https://github.com/tmenier/Flurl/tarball/master">TAR</a></li>
          <li class="title">DOWNLOADS</li>
        </nav>
      </div><!-- end header -->

    <div class="wrapper">

      <section>
        <div id="title">
          <h1>Flurl</h1>
          <p>Portable, fluent URL builder and testable HTTP for .NET</p>
          <hr>
          <span class="credits left">Project maintained by <a href="https://github.com/tmenier">tmenier</a></span>
          <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
        </div>

        <p>The full Flurl package is available on NuGet:</p>

<pre><code>PM&gt; Install-Package Flurl.Http
</code></pre>

<p>The stand-alone URL builder (without the HTTP extensions features) is here:</p>

<pre><code>PM&gt; Install-Package Flurl
</code></pre>

<h2>
<a name="docs" class="anchor" href="#docs"><span class="octicon octicon-link"></span></a>Docs</h2>

<ul>
<li><a href="#fluent-url">Fluent URL building</a></li>
<li><a href="#fluent-http">Fluent HTTP</a></li>
<li><a href="#testable-http">Testable HTTP</a></li>
<li><a href="#extensibility">Extensibility</a></li>
<li><a href="#portability">Portability</a></li>
<li><a href="#credits">Credits</a></li>
</ul><h2>
<a name="fluent-url-building" class="anchor" href="#fluent-url-building"><span class="octicon octicon-link"></span></a><a name="fluent-url"></a>Fluent URL Building</h2>

<p>Flurl's URL builder is best explained with an example:</p>

<div class="highlight highlight-c#"><pre><span class="kt">var</span> <span class="n">url</span> <span class="p">=</span> <span class="s">"http://www.some-api.com"</span>
    <span class="p">.</span><span class="n">AppendPathSegment</span><span class="p">(</span><span class="s">"endpoint"</span><span class="p">)</span>
    <span class="p">.</span><span class="n">SetQueryParams</span><span class="p">(</span><span class="k">new</span> <span class="p">{</span>
        <span class="n">api_key</span> <span class="p">=</span> <span class="n">ConfigurationManager</span><span class="p">.</span><span class="n">AppSettings</span><span class="p">[</span><span class="s">"SomeApiKey"</span><span class="p">],</span>
        <span class="n">max_results</span> <span class="p">=</span> <span class="m">20</span><span class="p">,</span>
        <span class="n">q</span> <span class="p">=</span> <span class="s">"Don't worry, I'll get encoded!"</span>
    <span class="p">});</span>
</pre></div>

<p>At its core is the <code>Url</code> class, which is designed to work seamlessly with strings, as demonstrated above. Creating a <code>Url</code> via a string extension is purly optional though; you can create one explicitly if you prefer:</p>

<div class="highlight highlight-c#"><pre><span class="kt">var</span> <span class="n">url</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Url</span><span class="p">(</span><span class="s">"http://www.some-api.com"</span><span class="p">).</span><span class="n">AppendPathSegment</span><span class="p">(...</span>
</pre></div>

<p>A <code>Url</code> also converts back to a string implicitly, so you can use it directly in any method that takes a string:</p>

<div class="highlight highlight-c#"><pre><span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="k">await</span> <span class="k">new</span> <span class="n">HttpClient</span><span class="p">.</span><span class="n">GetAsync</span><span class="p">(</span><span class="n">url</span><span class="p">);</span>
</pre></div>

<p>Flurl also contains the handy <code>Url.Combine</code> method, which is basically a <a href="http://msdn.microsoft.com/en-us/library/dd991142.aspx">Path.Combine</a> for URLs, ensuring one and only one separator character between segments:</p>

<div class="highlight highlight-c#"><pre><span class="kt">var</span> <span class="n">url</span> <span class="p">=</span> <span class="n">Url</span><span class="p">.</span><span class="n">Combine</span><span class="p">(</span><span class="s">"http://www.foo.com/"</span><span class="p">,</span> <span class="s">"/too/"</span><span class="p">,</span> <span class="s">"/many/"</span><span class="p">,</span> <span class="s">"/slashes/"</span><span class="p">,</span> <span class="s">"too"</span><span class="p">,</span> <span class="s">"few"</span><span class="p">);</span>
<span class="c1">// result: "http://www.foo.com/too/many/slashes/too/few"</span>
</pre></div>

<h3>
<a name="encoding" class="anchor" href="#encoding"><span class="octicon octicon-link"></span></a>Encoding</h3>

<p>Flurl takes care of encoding characters in URLs but takes a different approach with path segments than it does with query string values. The assumption is that query string values are highly variable (such as from user input), whereas path segments tend to be more "fixed" and may already be encoded, in which case you don't want to double-encode. Here are the rules Flurl follows:</p>

<ul>
<li>Query string values are fully URL-encoded.</li>
<li>For path segments, <em>reserved</em> characters such as <code>/</code> and <code>%</code> are <em>not</em> encoded.</li>
<li>For path segments, <em>illegal</em> characters such as spaces are encoded.</li>
<li>For path segments, the <code>?</code> character is encoded, since query strings get special treatment.</li>
</ul><h3>
<a name="url-api" class="anchor" href="#url-api"><span class="octicon octicon-link"></span></a>Url API</h3>

<p>The <code>Url</code> API is small, discoverable, and fairly self-explanatory. For completeness, here are all public methods and properties:</p>

<div class="highlight highlight-c#"><pre><span class="c1">// Static method:</span>

<span class="k">static</span> <span class="kt">string</span> <span class="nf">Combine</span><span class="p">(</span><span class="kt">string</span> <span class="n">url</span><span class="p">,</span> <span class="k">params</span> <span class="kt">string</span><span class="p">[]</span> <span class="n">segments</span><span class="p">);</span>

<span class="c1">// Instance methods (each with equivalent string extension):</span>

<span class="n">Url</span> <span class="nf">AppendPathSegment</span><span class="p">(</span><span class="kt">string</span> <span class="n">segment</span><span class="p">);</span>
<span class="n">Url</span> <span class="nf">AppendPathSegments</span><span class="p">(</span><span class="k">params</span> <span class="kt">string</span><span class="p">[]</span> <span class="n">segments</span><span class="p">);</span>
<span class="n">Url</span> <span class="nf">AppendPathSegments</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">segments</span><span class="p">);</span>
<span class="n">Url</span> <span class="nf">SetQueryParam</span><span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">object</span> <span class="k">value</span><span class="p">);</span>
<span class="n">Url</span> <span class="nf">SetQueryParams</span><span class="p">(</span><span class="kt">object</span> <span class="n">values</span><span class="p">);</span>
<span class="n">Url</span> <span class="nf">SetQueryParams</span><span class="p">(</span><span class="n">IDictionary</span> <span class="n">values</span><span class="p">);</span>
<span class="n">Url</span> <span class="nf">RemoveQueryParam</span><span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">);</span>
<span class="n">Url</span> <span class="nf">RemoveQueryParams</span><span class="p">(</span><span class="k">params</span> <span class="kt">string</span><span class="p">[]</span> <span class="n">names</span><span class="p">);</span>
<span class="n">Url</span> <span class="nf">RemoveQueryParams</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">names</span><span class="p">);</span>

<span class="c1">// Properties:</span>

<span class="kt">string</span> <span class="n">Path</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="n">IDictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">object</span><span class="p">&gt;</span> <span class="n">QueryParams</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
</pre></div>

<h2>
<a name="fluent-http" class="anchor" href="#fluent-http"><span class="octicon octicon-link"></span></a><a name="fluent-http"></a>Fluent HTTP</h2>

<p>Flurl allows you to perform many of the many common HTTP tasks (using asychronous HttpClient calls under the hood) directly off the fluent <code>Url</code> chain.</p>

<p>Get a strongly-typed poco from a JSON API:</p>

<div class="highlight highlight-c#"><pre><span class="n">T</span> <span class="n">poco</span> <span class="p">=</span> <span class="k">await</span> <span class="s">"http://api.foo.com"</span><span class="p">.</span><span class="n">GetJsonAsync</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>
</pre></div>

<p>Or if you prefer working with dynamics:</p>

<div class="highlight highlight-c#"><pre><span class="kt">dynamic</span> <span class="n">d</span> <span class="p">=</span> <span class="k">await</span> <span class="s">"http://api.foo.com"</span><span class="p">.</span><span class="n">GetJsonAsync</span><span class="p">();</span>
</pre></div>

<p>Get a string:</p>

<div class="highlight highlight-c#"><pre><span class="kt">string</span> <span class="n">s</span> <span class="p">=</span> <span class="k">await</span> <span class="s">"http://api.foo.com"</span><span class="p">.</span><span class="n">GetStringAsync</span><span class="p">();</span>
</pre></div>

<p>Download a file:</p>

<div class="highlight highlight-c#"><pre><span class="c1">// filename is optional here; it will default to the remote file name (image.jpg in this case)</span>
<span class="kt">var</span> <span class="n">path</span> <span class="p">=</span> <span class="k">await</span> <span class="s">"http://files.foo.com/image.jpg"</span><span class="p">.</span><span class="n">DownloadFileAsync</span><span class="p">(</span><span class="s">"c:\\downloads"</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
</pre></div>

<p>Post some JSON data:</p>

<div class="highlight highlight-c#"><pre><span class="k">await</span> <span class="s">"http://api.foo.com"</span><span class="p">.</span><span class="n">PostJsonAsync</span><span class="p">(</span><span class="k">new</span> <span class="p">{</span> <span class="n">a</span> <span class="p">=</span> <span class="m">1</span><span class="p">,</span> <span class="n">b</span> <span class="p">=</span> <span class="m">2</span> <span class="p">});</span>
</pre></div>

<p>Post some URL-encoded data (simulate an HTML form post):</p>

<div class="highlight highlight-c#"><pre><span class="k">await</span> <span class="s">"http://api.foo.com"</span><span class="p">.</span><span class="n">PostUrlEncodedAsync</span><span class="p">(</span><span class="k">new</span> <span class="p">{</span> <span class="n">a</span> <span class="p">=</span> <span class="m">1</span><span class="p">,</span> <span class="n">b</span> <span class="p">=</span> <span class="m">2</span> <span class="p">});</span>
</pre></div>

<p>Like the underlying HttpClient calls, the <code>Post*</code> methods above return a <code>Task&lt;HttpResponseMessage&gt;</code>. You may of course expect some data to be returned in the response body:</p>

<div class="highlight highlight-c#"><pre><span class="kt">var</span> <span class="n">poco</span> <span class="p">=</span> <span class="k">await</span> <span class="n">url</span><span class="p">.</span><span class="n">PostJsonAsync</span><span class="p">(</span><span class="k">new</span> <span class="p">{</span> <span class="n">a</span> <span class="p">=</span> <span class="m">1</span><span class="p">,</span> <span class="n">b</span> <span class="p">=</span> <span class="m">2</span> <span class="p">}).</span><span class="n">ReceiveJson</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>
<span class="kt">var</span> <span class="n">d</span> <span class="p">=</span> <span class="k">await</span> <span class="n">url</span><span class="p">.</span><span class="n">PostUrlEncodedAsync</span><span class="p">(</span><span class="k">new</span> <span class="p">{</span> <span class="n">a</span> <span class="p">=</span> <span class="m">1</span><span class="p">,</span> <span class="n">b</span> <span class="p">=</span> <span class="m">2</span> <span class="p">}).</span><span class="n">ReceiveJson</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">s</span> <span class="p">=</span> <span class="k">await</span> <span class="n">url</span><span class="p">.</span><span class="n">PostUrlEncodedAsync</span><span class="p">(</span><span class="k">new</span> <span class="p">{</span> <span class="n">a</span> <span class="p">=</span> <span class="m">1</span><span class="p">,</span> <span class="n">b</span> <span class="p">=</span> <span class="m">2</span> <span class="p">}).</span><span class="n">ReceiveString</span><span class="p">();</span>
</pre></div>

<p>(Note that the <code>Receive*</code> methods are themselves asynchronous, but they are extensions on <code>Task&lt;HttpResponseMessage&gt;</code>, making for a cleaner fluent chain where you need only <code>await</code> once.)</p>

<h3>
<a name="configuring-client-calls" class="anchor" href="#configuring-client-calls"><span class="octicon octicon-link"></span></a>Configuring Client Calls</h3>

<p>There are a variety of ways to set up HTTP calls without breaking the fluent chain.</p>

<p>Set a request header:</p>

<div class="highlight highlight-c#"><pre><span class="k">await</span> <span class="n">url</span><span class="p">.</span><span class="n">WithHeader</span><span class="p">(</span><span class="s">"someheader"</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">).</span><span class="n">GetJson</span><span class="p">();</span>
</pre></div>

<p>Set multiple request headers:</p>

<div class="highlight highlight-c#"><pre><span class="k">await</span> <span class="n">url</span><span class="p">.</span><span class="n">WithHeaders</span><span class="p">(</span><span class="k">new</span> <span class="p">{</span> <span class="n">header1</span> <span class="p">=</span> <span class="s">"foo"</span><span class="p">,</span> <span class="n">header2</span> <span class="p">=</span> <span class="s">"bar"</span> <span class="p">}}).</span><span class="n">GetJson</span><span class="p">();</span>
</pre></div>

<p>Authenticate with Basic Authentication:</p>

<div class="highlight highlight-c#"><pre><span class="k">await</span> <span class="n">url</span><span class="p">.</span><span class="n">WithBasicAuth</span><span class="p">(</span><span class="s">"username"</span><span class="p">,</span> <span class="s">"password"</span><span class="p">).</span><span class="n">GetJson</span><span class="p">();</span>
</pre></div>

<p>Authenticate with an OAuth bearer token (<a href="https://dev.twitter.com/docs/auth/application-only-auth">Twitter's application-only authentication</a> uses this):</p>

<div class="highlight highlight-c#"><pre><span class="k">await</span> <span class="n">url</span><span class="p">.</span><span class="n">WithBasicAuth</span><span class="p">(</span><span class="s">"username"</span><span class="p">,</span> <span class="s">"password"</span><span class="p">).</span><span class="n">GetJson</span><span class="p">();</span>
</pre></div>

<p>Specify a timeout:</p>

<div class="highlight highlight-c#"><pre><span class="k">await</span> <span class="n">url</span><span class="p">.</span><span class="n">WithTimeout</span><span class="p">(</span><span class="m">10</span><span class="p">).</span><span class="n">DownloadFile</span><span class="p">();</span> <span class="c1">// 10 seconds</span>
<span class="k">await</span> <span class="n">url</span><span class="p">.</span><span class="n">WithTimeout</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="n">FromMinutes</span><span class="p">(</span><span class="m">2</span><span class="p">)).</span><span class="n">DownloadFile</span><span class="p">();</span>
</pre></div>

<h3>
<a name="global-configuration" class="anchor" href="#global-configuration"><span class="octicon octicon-link"></span></a>Global Configuration</h3>

<p>The <code>FlurlHttp</code> object exposes a variety of static properties and methods that will apply to all Flurl-based HTTP calls made in your application. These should generally be set once at application startup (such as the <code>Application_Start</code> method in global.asax for ASP.NET applications).</p>

<div class="highlight highlight-c#"><pre><span class="n">FlurlHttp</span><span class="p">.</span><span class="n">DefaultTimeout</span> <span class="p">=</span> <span class="n">TimeSpan</span><span class="p">.</span><span class="n">FromSeconds</span><span class="p">(</span><span class="m">30</span><span class="p">);</span>
<span class="n">FlurlHttp</span><span class="p">.</span><span class="n">BeforeCall</span><span class="p">(</span><span class="n">request</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="c1">// do something before sending each HTTP request</span>
<span class="p">});</span>
<span class="n">FlurlHttp</span><span class="p">.</span><span class="n">BeforeCall</span><span class="p">((</span><span class="n">request</span><span class="p">,</span> <span class="n">response</span><span class="p">)</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="c1">// do something after each receiving each HTTP response</span>
<span class="p">});</span>
<span class="n">FlurlHttp</span><span class="p">.</span><span class="n">OnError</span><span class="p">((</span><span class="n">request</span><span class="p">,</span> <span class="n">response</span><span class="p">)</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="c1">// do something on every failed HTTP call</span>
<span class="p">});</span>
</pre></div>

<p><code>FlurlHttp</code> also exposes an <code>HttpClientFactory</code> property that allows you to customize how underlying <code>HttpClient</code> objects are constructed. The default factory should be adequate in most scenarios, but if you need a custom implementation, it is strongly advised to inherit from <code>DefaultHttpClientFactory</code> and extend the client returned by the base implementation. Much of Flurl's functionality, including callbacks, enhanced exceptions, and testability hooks, are dependent on the default factory and could break if you do not use the default as a starting point.</p>

<div class="highlight highlight-c#"><pre><span class="k">public</span> <span class="k">class</span> <span class="nc">MyCustomHttpClientFactory</span> <span class="p">:</span> <span class="n">DefaultHttpClientFactory</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">virtual</span> <span class="n">HttpClient</span> <span class="nf">CreateClient</span><span class="p">(</span><span class="n">Url</span> <span class="n">url</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">client</span> <span class="p">=</span> <span class="k">base</span><span class="p">.</span><span class="n">CreateClient</span><span class="p">(</span><span class="n">Url</span> <span class="n">url</span><span class="p">);</span>
        <span class="c1">// customize the client here</span>
        <span class="k">return</span> <span class="n">client</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h3>
<a name="enhanced-exceptions" class="anchor" href="#enhanced-exceptions"><span class="octicon octicon-link"></span></a>Enhanced Exceptions</h3>

<h2>
<a name="testable-http" class="anchor" href="#testable-http"><span class="octicon octicon-link"></span></a><a name="testable-http"></a>Testable HTTP</h2>

<p>Wouldn't it be great if you could simply "turn off" all real HTTP activity application-wide in your unit tests, without the need to wrap <code>HttpClient</code> in some interface? Flurl makes faking HTTP dead simple.</p>

<div class="highlight highlight-c#"><pre><span class="na">[Setup]</span>
<span class="k">public</span> <span class="nf">SetupFakeHttpBeforeEachTest</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">FlurlHttp</span><span class="p">.</span><span class="n">Testing</span><span class="p">.</span><span class="n">Reset</span><span class="p">();</span>
<span class="p">}</span>

<span class="na">[Test]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">DoFakeHttpCall</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">s</span> <span class="p">=</span> <span class="s">"http://api.foo.com"</span><span class="p">.</span><span class="n">GetStringAsync</span><span class="p">().</span><span class="n">Result</span><span class="p">;</span>
    <span class="n">Assert</span><span class="p">.</span><span class="n">That</span><span class="p">(</span><span class="s">"http://api.foo.com"</span><span class="p">.</span><span class="n">WasCalled</span><span class="p">().</span><span class="n">WithVerb</span><span class="p">(</span><span class="n">HttpVerb</span><span class="p">.</span><span class="n">Get</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>

<h2>
<a name="credits" class="anchor" href="#credits"><span class="octicon octicon-link"></span></a><a name="credits"></a>Credits</h2>

<p>Thanks to <a href="https://github.com/ghuntley">Geoffrey Huntley</a> for providing an intial portable implementation. </p>
      </section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>