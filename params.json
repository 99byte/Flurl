{"name":"Flurl","tagline":"Portable, fluent URL builder and testable HTTP for .NET","body":"The full Flurl package is available on NuGet:\r\n````\r\nPM> Install-Package Flurl.Http\r\n````\r\nThe stand-alone URL builder (without the HTTP extensions features) is here:\r\n````\r\nPM> Install-Package Flurl\r\n````\r\n\r\n##Docs\r\n\r\n- [Fluent URL building](#fluent-url)\r\n- [Fluent HTTP](#fluent-http)\r\n- [Testable HTTP](#testable-http)\r\n- [Extensibility](#extensibility)\r\n- [Portability](#portability)\r\n- [Credits](#credits)\r\n\r\n##<a name=\"fluent-url\"></a>Fluent URL Building\r\n\r\n\r\nFlurl's URL builder is best explained with an example:\r\n\r\n````c#\r\nvar url = \"http://www.some-api.com\"\r\n\t.AppendPathSegment(\"endpoint\")\r\n\t.SetQueryParams(new {\r\n\t\tapi_key = ConfigurationManager.AppSettings[\"SomeApiKey\"],\r\n\t\tmax_results = 20,\r\n\t\tq = \"Don't worry, I'll get encoded!\"\r\n\t});\r\n````\r\n\r\nAt its core is the `Url` class, which is designed to work seamlessly with strings, as demonstrated above. Creating a `Url` via a string extension is purly optional though; you can create one explicitly if you prefer:\r\n\r\n````c#\r\nvar url = new Url(\"http://www.some-api.com\").AppendPathSegment(...\r\n````\r\n\r\nA `Url` also converts back to a string implicitly, so you can use it directly in any method that takes a string:\r\n\r\n````c#\r\nvar result = await new HttpClient.GetAsync(url);\r\n````\r\n\r\nFlurl also contains the handy `Url.Combine` method, which is basically a [Path.Combine](http://msdn.microsoft.com/en-us/library/dd991142.aspx) for URLs, ensuring one and only one separator character between segments:\r\n\r\n````c#\r\nvar url = Url.Combine(\"http://www.foo.com/\", \"/too/\", \"/many/\", \"/slashes/\", \"too\", \"few\");\r\n// result: \"http://www.foo.com/too/many/slashes/too/few\"\r\n````\r\n\r\n###Encoding\r\n\r\nFlurl takes care of encoding characters in URLs but takes a different approach with path segments than it does with query string values. The assumption is that query string values are highly variable (such as from user input), whereas path segments tend to be more \"fixed\" and may already be encoded, in which case you don't want to double-encode. Here are the rules Flurl follows:\r\n\r\n- Query string values are fully URL-encoded.\r\n- For path segments, *reserved* characters such as `/` and `%` are *not* encoded.\r\n- For path segments, *illegal* characters such as spaces are encoded.\r\n- For path segments, the `?` character is encoded, since query strings get special treatment.\r\n\r\n###Url API\r\n\r\nThe `Url` API is small, discoverable, and fairly self-explanatory. For completeness, here are all public methods and properties:\r\n\r\n````c#\r\n// Static method:\r\n\r\nstatic string Combine(string url, params string[] segments);\r\n\r\n// Instance methods (each with equivalent string extension):\r\n\r\nUrl AppendPathSegment(string segment);\r\nUrl AppendPathSegments(params string[] segments);\r\nUrl AppendPathSegments(IEnumerable<string> segments);\r\nUrl SetQueryParam(string name, object value);\r\nUrl SetQueryParams(object values);\r\nUrl SetQueryParams(IDictionary values);\r\nUrl RemoveQueryParam(string name);\r\nUrl RemoveQueryParams(params string[] names);\r\nUrl RemoveQueryParams(IEnumerable<string> names);\r\n\r\n// Properties:\r\n\r\nstring Path { get; }\r\nIDictionary<string, object> QueryParams { get; }\r\n````\r\n\r\n##<a name=\"fluent-http\"></a>Fluent HTTP\r\n\r\nFlurl allows you to perform many of the many common HTTP tasks (using asychronous HttpClient calls under the hood) directly off the fluent `Url` chain.\r\n\r\nGet a strongly-typed poco from a JSON API:\r\n````c#\r\nT poco = await \"http://api.foo.com\".GetJsonAsync<T>();\r\n````\r\nOr if you prefer working with dynamics:\r\n````c#\r\ndynamic d = await \"http://api.foo.com\".GetJsonAsync();\r\n````\r\nGet a string:\r\n````c#\r\nstring s = await \"http://api.foo.com\".GetStringAsync();\r\n````\r\nDownload a file:\r\n````c#\r\n// filename is optional here; it will default to the remote file name (image.jpg in this case)\r\nvar path = await \"http://files.foo.com/image.jpg\".DownloadFileAsync(\"c:\\\\downloads\", filename);\r\n````\r\nPost some JSON data:\r\n````c#\r\nawait \"http://api.foo.com\".PostJsonAsync(new { a = 1, b = 2 });\r\n````\r\nPost some URL-encoded data (simulate an HTML form post):\r\n````c#\r\nawait \"http://api.foo.com\".PostUrlEncodedAsync(new { a = 1, b = 2 });\r\n````\r\nLike the underlying HttpClient calls, the `Post*` methods above return a `Task<HttpResponseMessage>`. You may of course expect some data to be returned in the response body:\r\n````c#\r\nvar poco = await url.PostJsonAsync(new { a = 1, b = 2 }).ReceiveJson<T>();\r\nvar d = await url.PostUrlEncodedAsync(new { a = 1, b = 2 }).ReceiveJson();\r\nvar s = await url.PostUrlEncodedAsync(new { a = 1, b = 2 }).ReceiveString();\r\n````\r\n(Note that the `Receive*` methods are themselves asynchronous, but they are extensions on `Task<HttpResponseMessage>`, making for a cleaner fluent chain where you need only `await` once.)\r\n\r\n###Configuring Client Calls\r\n\r\nThere are a variety of ways to set up HTTP calls without breaking the fluent chain.\r\n\r\nSet a request header:\r\n````c#\r\nawait url.WithHeader(\"someheader\", \"foo\").GetJson();\r\n````\r\nSet multiple request headers:\r\n````c#\r\nawait url.WithHeaders(new { header1 = \"foo\", header2 = \"bar\" }}).GetJson();\r\n````\r\nAuthenticate with Basic Authentication:\r\n````c#\r\nawait url.WithBasicAuth(\"username\", \"password\").GetJson();\r\n````\r\nAuthenticate with an OAuth bearer token ([Twitter's application-only authentication](https://dev.twitter.com/docs/auth/application-only-auth) uses this):\r\n````c#\r\nawait url.WithBasicAuth(\"username\", \"password\").GetJson();\r\n````\r\nSpecify a timeout:\r\n````c#\r\nawait url.WithTimeout(10).DownloadFile(); // 10 seconds\r\nawait url.WithTimeout(TimeSpan.FromMinutes(2)).DownloadFile();\r\n````\r\n\r\n###Global Configuration\r\n\r\nThe `FlurlHttp` object exposes a variety of static properties and methods that will apply to all Flurl-based HTTP calls made in your application. These should generally be set once at application startup (such as the `Application_Start` method in global.asax for ASP.NET applications).\r\n\r\n````c#\r\nFlurlHttp.DefaultTimeout = TimeSpan.FromSeconds(30);\r\nFlurlHttp.BeforeCall(request =>\r\n{\r\n    // do something before sending each HTTP request\r\n});\r\nFlurlHttp.BeforeCall((request, response) =>\r\n{\r\n    // do something after each receiving each HTTP response\r\n});\r\nFlurlHttp.OnError((request, response) =>\r\n{\r\n    // do something on every failed HTTP call\r\n});\r\n````\r\n`FlurlHttp` also exposes an `HttpClientFactory` property that allows you to customize how underlying `HttpClient` objects are constructed. The default factory should be adequate in most scenarios, but if you need a custom implementation, it is strongly advised to inherit from `DefaultHttpClientFactory` and extend the client returned by the base implementation. Much of Flurl's functionality, including callbacks, enhanced exceptions, and testability hooks, are dependent on the default factory and could break if you do not use the default as a starting point.\r\n\r\n````c#\r\npublic class MyCustomHttpClientFactory : DefaultHttpClientFactory\r\n{\r\n    public virtual HttpClient CreateClient(Url url)\r\n    {\r\n    \tvar client = base.CreateClient(Url url);\r\n        // customize the client here\r\n        return client;\r\n    }\r\n}\r\n````\r\n\r\n###Enhanced Exceptions\r\n\r\n##<a name=\"testable-http\"></a>Testable HTTP\r\n\r\nWouldn't it be great if you could simply \"turn off\" all real HTTP activity application-wide in your unit tests, without the need to wrap `HttpClient` in some interface? Flurl makes faking HTTP dead simple.\r\n\r\n````c#\r\n[Setup]\r\npublic SetupFakeHttpBeforeEachTest()\r\n{\r\n\tFlurlHttp.Testing.Reset();\r\n}\r\n\r\n[Test]\r\npublic void DoFakeHttpCall()\r\n{\r\n    var s = \"http://api.foo.com\".GetStringAsync().Result;\r\n    Assert.That(\"http://api.foo.com\".WasCalled().WithVerb(HttpVerb.Get));\r\n}\r\n````\r\n\r\n\r\n\r\n##<a name=\"credits\"></a>Credits\r\n\r\nThanks to [Geoffrey Huntley](https://github.com/ghuntley) for providing an intial portable implementation. \r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}